# Проектирование интерпретатора bash

Реализовать интерпретатор предполагается на Golang.

Для того чтобы запустить интерпретатор, нужно будет запустить соответствующий исполняемый файл, который получатеся после сборки приложения из исходных кодов на Golang
```bash
go build -o go-cli
./go-cli
>echo "Hello, world!"
Hello, world!
>exit
```
Соответственно, запуск собранного исполняемого файла будет **точкой входа** в интерпретатор.  
**Точкой выхода** из него будет команда `exit`, которая совершит выход из интерпретатора и завешит соответствующий процесс.  

## Обработка команд в интерпретаторе
Формат команд, которые пользователь может вводить в интерпретатор выглядит следующим образом

### Полная команда
```
[VAR1=value1 ...] command_name [arg1] ... 
```
- Перед командой опционально могут добавляться ее переменные окружения
- Затем идет название команды (`command_name`) и (при наличии) ее аргументы, разделенные пробелами
- Значение `command_name` проверяется следующим образом:  
  * Сначала проверяется наличие `command_name` во встроенных (builtin) командах, изначально поддерживается следующий список( который впоследствии можно будет расширить)  
    * `cat [FILE]` - вывод на экран содержимого файла
    * `echo [arg] ...` - вывод на экран переданных аргументов
    * `wc [FILE]` - вывод количества слов/строк/байт в файле
    * `pwd` - вывод текущей директории
    * `exit` - выход из интерпретатора
  * Если `command_name` не был найден в списке встроенных (builtin) командах, то следующим будет выполнятся поиск исполняемого файла с названием `command_name` в одной из директорий, перечисленных в переменной окружения `PATH` в формате `PATH=<dir_path1>:<dir_path_2>...:<dir_path_n>`  
    * Если исполняемый файл будет найден в одной из данных директорий, то он будет запушен с переданными аргументами в отдельном процессе (через Process или его аналоги)
  * Если `command_name` в `PATH` не будет найден, то в терминал выведется соовтветствующее сообщение об ошибке (о том что интерпретатор не смог распознать введенную команду).


### Пайплайны
Также нужно отметить, что интерпретатор поддерживает объединение нескольких команд (в вышеописанном формате) в pipeline через символ `|`:  
```
cmd_1 | cmd_2 | ... | cmd_n
```
где на stdin текущей команде передается stdout предыдущей.

### Команды для обновления окружения (неполные команды)
В дополнение к вышеописанному формату команды, также интерпретатор должен поддерживать неполный формат команды, где отсутствует `command_name` и задается только окружение, которое обновляет глобальные переменные интерпретатора
```
> FILE=example.txt
> cat $FILE
Some example text

```

## Общая схема

При проектировании работы интерпретатора выделяются три подсистемы: `препроцессинга`, `парсинга` и `выполнения команды`.  

![subsystems_diagram](./img/subsystems_diagram.png)

При вводе данных пользователем в интерпретаторе, сначала отрабатывает подсистема препроцессинга. Она выполняет все подстановки $ (внутри " или при отсутствии любых, при '' оставляет как есть) в исходных данных.  

Затем, после препроцессинга, выполняется парсинг данных. Парсинг разбирает полученные данные, чтобы получить команду (`Command`), которая имеет следующие составляющие:
- имя исполняемого файла (name)
- переданные аргументы (args, массив слов разделенных через пробел (кроме аргументов обрамленных кавычками), начиная с 1 индекса, 0 это name)
- поток стандартного ввода (stdin)
- поток стандартного вывода (stdout)
- поток ошибок (stderr)
- код возврата (ReturnCode)
- окружение (env)
- текущая директория (CurrentDir, при первоначальном запуске можно унаследовать от родительского процесса)

И на заверщающем этапе, после парсинга, сформированные команды исполняются в соответствующей подсистеме выполнения.  
В одной строке, вводимой в интерпретатор, может быть одна или несколько команд. Если переданы несколько команд, то они связываются через пайп `|`, где на stdin текущей команде передается stdout предыдущей.  

Ниже представлена примерная диаграмма классов:
![class_diagramm](./img/class_diagramm.png)

- `Substitutor` - класс, который в поле `Input` хранит исходную строку пользователя и через метод `Eval()` выполняет подстановку переменных через `$`
- `Parser` - класс, который в поле `SubstituedInput` хранит сторку в которой разрешены все подстановки, и список поддерживаемых команд в `AllowedCommands`. Через метод `Parse()` осуществляется парсинг строки, который возвращает объект класса `Command`
- `Pipeline` - класс, который выполняет все команды из поля `Commands` (если их несколько, переданных через `|`), указанные в строке через метод `Run()`