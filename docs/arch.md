# Проектирование интерпретатора bash

Реализовать интерпретатор предполагается на Golang.

Для того чтобы запустить интерпретатор, нужно будет запустить соответствующий исполняемый файл, который получатеся после сборки приложения из исходных кодов на Golang
```bash
go build -o go-cli
./go-cli
>echo "Hello, world!"
Hello, world!
>exit
```
Соответственно, запуск собранного исполняемого файла будет **точкой входа** в интерпретатор.  
**Точкой выхода** из него будет команда `exit`, которая совершит выход из интерпретатора и завешит соответствующий процесс.  

## Обработка команд в интерпретаторе
Формат команд, которые пользователь может вводить в интерпретатор выглядит следующим образом

### Полная команда
```
[VAR1=value1 ...] command_name [arg1] ... 
```
- Перед командой опционально могут добавляться ее переменные окружения
- Затем идет название команды (`command_name`) и (при наличии) ее аргументы, разделенные пробелами
- Значение `command_name` проверяется следующим образом:  
  * Сначала проверяется наличие `command_name` во встроенных (builtin) командах, изначально поддерживается следующий список( который впоследствии можно будет расширить)  
    * `cat [FILE]` - вывод на экран содержимого файла
    * `echo [arg] ...` - вывод на экран переданных аргументов
    * `wc [FILE]` - вывод количества слов/строк/байт в файле
    * `pwd` - вывод текущей директории
    * `exit` - выход из интерпретатора
  * Если `command_name` не был найден в списке встроенных (builtin) командах, то следующим будет выполнятся поиск исполняемого файла с названием `command_name` в одной из директорий, перечисленных в переменной окружения `PATH` в формате `PATH=<dir_path1>:<dir_path_2>...:<dir_path_n>`  
    * Если исполняемый файл будет найден в одной из данных директорий, то он будет запушен с переданными аргументами в отдельном процессе (через Process или его аналоги)
  * Если `command_name` в `PATH` не будет найден, то в терминал выведется соовтветствующее сообщение об ошибке (о том что интерпретатор не смог распознать введенную команду).


### Пайплайны
Также нужно отметить, что интерпретатор поддерживает объединение нескольких команд (в вышеописанном формате) в pipeline через символ `|`:  
```
cmd_1 | cmd_2 | ... | cmd_n
```
где на stdin текущей команде передается stdout предыдущей.

### Команды для обновления окружения (неполные команды)
В дополнение к вышеописанному формату команды, также интерпретатор должен поддерживать неполный формат команды, где отсутствует `command_name` и задается только окружение, которое обновляет глобальные переменные интерпретатора
```
> FILE=example.txt
> cat $FILE
Some example text

```

## Общая схема

При проектировании работы интерпретатора выделяются три подсистемы: `препроцессинга`, `парсинга` и `выполнения команды`.  

![subsystems_diagram](./img/subsystems_diagram.png)

При вводе данных пользователем в интерпретаторе, сначала отрабатывает подсистема препроцессинга. Она выполняет все подстановки $ (внутри " или при отсутствии любых, при '' оставляет как есть) в исходных данных.  

Затем, после препроцессинга, выполняется парсинг данных. Парсинг разбирает полученные данные, чтобы получить команду (`Command`), которая имеет следующие составляющие:
- имя исполняемого файла (name)
- переданные аргументы (args, массив слов разделенных через пробел (кроме аргументов обрамленных кавычками), начиная с 1 индекса, 0 это name)
- поток стандартного ввода (stdin)
- поток стандартного вывода (stdout)
- поток ошибок (stderr)
- окружение (env)
- текущая директория (CurrentDir, при первоначальном запуске можно унаследовать от родительского процесса)

И на заверщающем этапе, после парсинга, сформированные команды исполняются в соответствующей подсистеме выполнения.  
В одной строке, вводимой в интерпретатор, может быть одна или несколько команд. Если переданы несколько команд, то они связываются через пайп `|`, где на stdin текущей команде передается stdout предыдущей.  

Ниже представлена примерная диаграмма классов:
![class_diagramm](./img/class_diagramm.png)


- `Interpreter` - класс, который является точкой входа в интерпретатор через метод `Start()`.  
  В данном методе обрабатываются введенные пользователем данные в интерпретатор до тех пор пока он не введет `exit`.  
  В цикле, обработка пользовтельских данных устроена следующим образом:
  1. Сначала данные обрабытаваются через метод `substitute(userInput)` для подстановки всех переменных, на выходе получается `SubstitutedInput` - строка со всеми разрешенными подстановками
  2. Затем, используя объект `Parser` в поле `CmdParser`, запускает парсинг команды через `CmdParser.Parse(SubstitutedInput, globalEnv)` и в результате получает объект `pipeline` класса `Pipeline`, где каждая команда копирует в свое окружение `globalEnv`
  3. Запускает пайплайн через `pipeline.Run()` и обрабатывает результат запуска команд.
- `Parser` - класс, который разбирает переданную строку `SubstitutedInput` с подставленными переменными через метод `Parse()`.  
  `Parse` выполняет разбор переданной строки и возвращает объект класса `Pipeline` (массив `ParsedCommand`).  
  Как было описано выше, переданная команда может быть:
  - builtin (встроенной) командой
  - если такой встроенной команды нет, тогда выполняется поиск внешней программы в PATH
  - если команды не оказалось и там, то Parser выбросит исключение `Command nout found`
  - также отдельно выделяются команды, которые только обновляют значение переменной окружения
  Для реализации этого выбора, класс `Parser` имеет поле `BuiltinCommands`, которое представляет собой массив объектов `BuiltinCommand`, а также `GlobalEnv`в методе `Parse()`
- `BuiltinCommand` - это интерфейс, который представляет встроенную команду. Реализовав его, можно добавлять новые команды по аналогии с `echo`, `cat`, `pwd`, `wc`, `exit`.
- `Pipeline` - класс, который выполняет все команды из поля `Commands` (если их несколько, переданных через `|`), указанные в строке через метод `Run()`
- `ParsedCommand` - класс, который представляет собой команду, которая получается в результате парсинга и является состовляющей `Pipeline`. Класс имеет поле `commandExecutor`, которое является объектом реализующим интерфейс `CommandExecutor`. При помощи данного интерфейса есть возможность выполнять команду в независимости от того, является ли эта команда внешней, встроенной или командной которая только изменяет Env